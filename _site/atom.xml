<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Night[9]</title>
 <link href="http://chrislundquist.github.com/atom.xml" rel="self"/>
 <link href="http://chrislundquist.github.com"/>
 <updated>2012-03-05T18:46:05-08:00</updated>
 <id>http://chrislundquist.github.com</id>
 <author>
   <name>Chris Lundquist</name>
   <email>ChrisMLundquist@gmail.com</email>
 </author>

 
 <entry>
   <title>Video Encoding Terminology</title>
   <link href="http://chrislundquist.github.com/Video Encoding/2012/03/05/video-encoding-terminology"/>
   <updated>2012-03-05T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Video Encoding/2012/03/05/video-encoding-terminology</id>
   <content type="html">&lt;p&gt;MB - Macro Block, a group of pixels, often square usually between 16 x 16 and 4 x 4, some encoders allow 8 x 4 and the like.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Leveraging Frameworks: dependent => :destroy</title>
   <link href="http://chrislundquist.github.com/Rails Development/2012/03/05/leveraging-frameworks-dependent--destroy"/>
   <updated>2012-03-05T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Rails Development/2012/03/05/leveraging-frameworks-dependent--destroy</id>
   <content type="html">&lt;p&gt;Maybe you have some code like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;model Foo &amp;lt; ActiveRecord::Base
    has_many :bars
    before_destroy :clean_up_bars

    def clean_up_bars
       self.bars.destroy_all
    end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My main gripe with this, is that Rails provides an awesome way to clean up any thing that doesn&amp;#8217;t make sense without a parent. Fortunately it is even super simple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;model Foo &amp;lt; ActiveRecord::Base
    has_many :bars
    before_destroy :clean_up_bars, :dependent =&amp;gt; :destroy
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will make it so that when your Foo instance is destroyed, it will also destroy each of the bars that belong to that Foo instance.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>March Challenge</title>
   <link href="http://chrislundquist.github.com/Challenges/2012/03/01/march-challenge"/>
   <updated>2012-03-01T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Challenges/2012/03/01/march-challenge</id>
   <content type="html">&lt;h2 id='big_ideas'&gt;Big Ideas&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Create an Open source load balancing API&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Basically a wrapper around HA proxy and your application that needs it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Write a WebGL graphing library.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Seems like the barrier to use WebGL could be lower.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Write a binary gem building system.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In reference to Katz&amp;#8217;s speech at Ruby on Ales.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Small steps</title>
   <link href="http://chrislundquist.github.com/Development/2012/02/29/small-steps"/>
   <updated>2012-02-29T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Development/2012/02/29/small-steps</id>
   <content type="html">&lt;p&gt;&lt;em&gt;Premature optimization and extension can cause many more problems than gains.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It is often the case where we try to extend or improve things before that are complete. This usually leads to the manifestation of many bugs. The root cause of this is &lt;em&gt;taking too many or too large of steps at a time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One way to tell when this is happening, is when you start writing many different functions at a time, but aren&amp;#8217;t able to finish any of them. My strategy here is to find the separation of concerns and establish the minimum amount of work I need to do to accomplish this step. The three C&amp;#8217;s of computer science can be an excellent guide.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Correctness&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Having a ugly function that works correctly, is better than a shorter one that has bugs.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Completeness&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;If you don&amp;#8217;t account for half of your cases, then it is an obvious bug.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Compactness&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;It is a fairly common saying, something isn&amp;#8217;t done when there is nothing left to add. It is done when there is nothing left to take away.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The order of these guidelines is very important. You first need to do something correctly before it is time to extend it all the way. Likewise, an empty function is very compact, but not complete.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Faking it</title>
   <link href="http://chrislundquist.github.com/Development/2012/02/28/faking-it"/>
   <updated>2012-02-28T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Development/2012/02/28/faking-it</id>
   <content type="html">&lt;p&gt;&lt;em&gt;Faking it is the opposite of mastery. Faking it is learning (hopefully)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id='what_it_is'&gt;What it is&lt;/h3&gt;

&lt;p&gt;Sometimes you find yourself learning a new framework, tool, or language. Usually the first while is spent reading, and trying to gain some clarity. Eventually you gain enough confidence to try to do your task, but expressing what you mean to the new tool can be difficult. Often you will &lt;em&gt;copy paste a similar section&lt;/em&gt; to what you want, using it as a template. Then you substitute your needs into the template, along the way fixing the minor errors that crop of from this process. Always with a clear goal, and gaining a little insight each time.&lt;/p&gt;

&lt;p&gt;Another common method is &lt;em&gt;to pattern after a familiar language&lt;/em&gt;. This is usually a better strategy, because it means you have more confidence in what you are actually doing. For example, when I was learning Java, patterning things after C++ let me cover more ground quickly. Since the syntax is so close, this can be a valid strategy, and even indicates a higher level of mastery than that of copy pasting a template and having at it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Faking is not a bad thing. It is a great way to dive in and start to learn&lt;/em&gt;, it only becomes a problem when faking it becomes a crutch.&lt;/p&gt;

&lt;h3 id='how_to_tell_when_when_you_really_mean_it'&gt;How to tell when when you really mean it&lt;/h3&gt;

&lt;p&gt;Usually you can tell when you aren&amp;#8217;t faking it when you stop copy pasting from examples or when you aren&amp;#8217;t switching tabs constantly to copy someone else&amp;#8217;s code. There will always be times when you need a reference by running a quick search. This is distinctly different from switching back and forth between tabs or copy pasting large swaths of code.&lt;/p&gt;

&lt;p&gt;Most of all, mastery is apparent when you can &lt;em&gt;express your goal in a clear and succinct manor&lt;/em&gt; to or in your given tool or language, without needing a reference.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Panic Fire. How to recognize it and keep your coworkers from going postal</title>
   <link href="http://chrislundquist.github.com/Development/2012/02/27/panic-fire-how-to-recognize-it-and-keep-your-coworkers-from-going-postal"/>
   <updated>2012-02-27T00:00:00-08:00</updated>
   <id>hhttp://chrislundquist.github.com/Development/2012/02/27/panic-fire-how-to-recognize-it-and-keep-your-coworkers-from-going-postal</id>
   <content type="html">&lt;p&gt;So maybe you have found yourself or seen someone else in a situation like this.&lt;/p&gt;

&lt;p&gt;You are working on a project, without the time to get to know all the pieces. You are almost finished, there are just a few lines of code standing between you and getting lunch. There is just this one error you are stuck with. You try changing the problem line and get a wildly different error. Quickly, you change it again, to get another new error. You modify a few lines above with haste, hoping to stop the issue below, but that instead breaks in yet another new and interesting way.&lt;/p&gt;

&lt;p&gt;This cycle continues, ever so slowly bringing you closer to your goal. Finally, after repeatedly and hastily running back in forth reactively pushing lines of code &amp;#8220;back in place&amp;#8221;. You have completed the goal. You pause for a moment and look back over your code, not quite sure why half of it is there. You just remember it fixed some error that cropped up from this other error over there&amp;#8230; Actually you only have a vague idea how you accomplished this task. All you know is that it works now, some how.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This is panic fire&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next time you see yourself or someone you know in this situation here are some suggestions to help them break the cycle.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ask what they are trying to accomplish.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If they can&amp;#8217;t say what they are trying to do in 20 words or less, they need to take smaller steps.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ask how they are going to accomplish the goal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If they don&amp;#8217;t have a game plan in English, then it is really hard to express that plan in code. Even in a language as poetic as Ruby.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ask why making a change will bring them closer to their goal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If they don&amp;#8217;t know why they are doing something, it is time to get a reality check&lt;/p&gt;

&lt;p&gt;To summarize, ask:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What are they doing&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How they are going to do it&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why it will work&lt;/em&gt;&lt;/p&gt;</content>
 </entry>
 
 
</feed>